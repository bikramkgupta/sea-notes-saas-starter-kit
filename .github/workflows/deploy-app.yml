name: Deploy to DigitalOcean App Platform

# Manual trigger only - no automatic deployments
on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - deploy
          - delete
          - env-vars
        default: 'deploy'
      app_spec_path:
        description: 'Path to app spec file'
        required: false
        default: '.do/app.yaml'
      include_only_env_vars:
        description: 'Comma-separated list of env vars to update (leave empty to update all)'
        required: false
        default: ''

# Secrets available for ${VAR} substitution in app specs
# Add your secrets to GitHub Secrets, use ${SECRET_NAME} in your app spec
env:
  # GitHub (for private repos)
  APP_GITHUB_TOKEN: ${{ secrets.APP_GITHUB_TOKEN }}
  # Auto-populate the repo URL used by the dev container
  GITHUB_REPO_URL: https://github.com/${{ github.repository }}
  # Database
  DATABASE_URL: ${{ secrets.DATABASE_URL }}
  REDIS_URL: ${{ secrets.REDIS_URL }}
  MONGODB_URI: ${{ secrets.MONGODB_URI }}
  # Auth
  AUTH_SECRET: ${{ secrets.AUTH_SECRET }}
  NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
  NEXTAUTH_URL: ${{ secrets.NEXTAUTH_URL }}
  JWT_SECRET: ${{ secrets.JWT_SECRET }}
  SESSION_SECRET: ${{ secrets.SESSION_SECRET }}
  # API Keys
  API_KEY: ${{ secrets.API_KEY }}
  API_SECRET: ${{ secrets.API_SECRET }}
  OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
  ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
  GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
  # OAuth
  GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
  GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
  GITHUB_CLIENT_ID: ${{ secrets.GITHUB_CLIENT_ID }}
  GITHUB_CLIENT_SECRET: ${{ secrets.GITHUB_CLIENT_SECRET }}
  # Payment
  STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
  STRIPE_WEBHOOK_SECRET: ${{ secrets.STRIPE_WEBHOOK_SECRET }}
  STRIPE_PUBLISHABLE_KEY: ${{ secrets.STRIPE_PUBLISHABLE_KEY }}
  # Cloud
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  AWS_REGION: ${{ secrets.AWS_REGION }}
  S3_BUCKET: ${{ secrets.S3_BUCKET }}
  # Email
  SMTP_HOST: ${{ secrets.SMTP_HOST }}
  SMTP_USER: ${{ secrets.SMTP_USER }}
  SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
  SENDGRID_API_KEY: ${{ secrets.SENDGRID_API_KEY }}
  RESEND_API_KEY: ${{ secrets.RESEND_API_KEY }}
  MAILGUN_API_KEY: ${{ secrets.MAILGUN_API_KEY }}
  # Analytics/Monitoring
  SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
  POSTHOG_API_KEY: ${{ secrets.POSTHOG_API_KEY }}
  SEGMENT_WRITE_KEY: ${{ secrets.SEGMENT_WRITE_KEY }}
  # Custom secrets (add up to 10)
  CUSTOM_SECRET_1: ${{ secrets.CUSTOM_SECRET_1 }}
  CUSTOM_SECRET_2: ${{ secrets.CUSTOM_SECRET_2 }}
  CUSTOM_SECRET_3: ${{ secrets.CUSTOM_SECRET_3 }}
  CUSTOM_SECRET_4: ${{ secrets.CUSTOM_SECRET_4 }}
  CUSTOM_SECRET_5: ${{ secrets.CUSTOM_SECRET_5 }}
  CUSTOM_SECRET_6: ${{ secrets.CUSTOM_SECRET_6 }}
  CUSTOM_SECRET_7: ${{ secrets.CUSTOM_SECRET_7 }}
  CUSTOM_SECRET_8: ${{ secrets.CUSTOM_SECRET_8 }}
  CUSTOM_SECRET_9: ${{ secrets.CUSTOM_SECRET_9 }}
  CUSTOM_SECRET_10: ${{ secrets.CUSTOM_SECRET_10 }}

permissions:
  contents: read

jobs:
  deploy:
    if: ${{ inputs.action == 'deploy' }}
    runs-on: ubuntu-latest
    steps:
      - name: Debug - Show selected action
        run: |
          echo "Selected action: ${{ inputs.action }}"
          echo "App spec path: ${{ inputs.app_spec_path }}"

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Validate app spec exists
        run: |
          if [ ! -f "${{ inputs.app_spec_path }}" ]; then
            echo "Error: App spec not found at ${{ inputs.app_spec_path }}"
            echo ""
            echo "Create an app spec file. See app-specs/ for examples."
            exit 1
          fi
          echo "Using app spec: ${{ inputs.app_spec_path }}"
          cat "${{ inputs.app_spec_path }}"

      - name: Deploy to DigitalOcean
        uses: digitalocean/app_action/deploy@v2
        id: deploy
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          app_spec_location: ${{ inputs.app_spec_path }}
          print_build_logs: false
          print_deploy_logs: false

      - name: Output deployment info
        run: |
          echo "## Deployment Successful!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          APP_OUTPUT='${{ steps.deploy.outputs.app }}'
          APP_NAME=$(echo "$APP_OUTPUT" | jq -r '.spec.name // empty')
          APP_URL=$(echo "$APP_OUTPUT" | jq -r '.live_url // empty')
          APP_ID=$(echo "$APP_OUTPUT" | jq -r '.id // empty')

          echo "**App Name:** $APP_NAME" >> $GITHUB_STEP_SUMMARY
          if [ -n "$APP_URL" ]; then
            echo "**Live URL:** $APP_URL" >> $GITHUB_STEP_SUMMARY
          fi
          if [ -n "$APP_ID" ]; then
            echo "**App ID:** \`$APP_ID\`" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Debug Commands" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "# View logs" >> $GITHUB_STEP_SUMMARY
          echo "doctl apps logs $APP_ID" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# SSH into container" >> $GITHUB_STEP_SUMMARY
          echo "doctl apps console $APP_ID" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  delete:
    if: ${{ inputs.action == 'delete' }}
    runs-on: ubuntu-latest
    steps:
      - name: Debug - Show selected action
        run: |
          echo "Selected action: ${{ inputs.action }}"
          echo "App spec path: ${{ inputs.app_spec_path }}"

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Get app name from spec
        id: appname
        run: |
          SPEC_PATH="${{ inputs.app_spec_path }}"
          if [ -f "$SPEC_PATH" ]; then
            APP_NAME=$(yq '.name' "$SPEC_PATH" 2>/dev/null || echo "")
          fi
          if [ -z "$APP_NAME" ] || [ "$APP_NAME" = "null" ]; then
            echo "Error: Could not read app name from $SPEC_PATH"
            exit 1
          fi
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
          echo "Deleting app: $APP_NAME"

      - name: Delete app from DigitalOcean
        uses: digitalocean/app_action/delete@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}
          app_name: ${{ steps.appname.outputs.app_name }}
          ignore_not_found: true

      - name: Output deletion info
        run: |
          echo "## App Deleted" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**App Name:** ${{ steps.appname.outputs.app_name }}" >> $GITHUB_STEP_SUMMARY

  update-env-vars:
    if: ${{ inputs.action == 'env-vars' }}
    runs-on: ubuntu-latest
    steps:
      - name: Debug - Show selected action
        run: |
          echo "Selected action: ${{ inputs.action }}"
          echo "App spec path: ${{ inputs.app_spec_path }}"
          echo "Include only env vars: ${{ inputs.include_only_env_vars }}"

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install tools
        run: |
          # Install yq for YAML parsing
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

          # Install doctl
          DOCTL_VERSION=$(curl -s https://api.github.com/repos/digitalocean/doctl/releases/latest | jq -r .tag_name | sed 's/^v//')
          curl -sL "https://github.com/digitalocean/doctl/releases/download/v${DOCTL_VERSION}/doctl-${DOCTL_VERSION}-linux-amd64.tar.gz" | tar -xzv
          sudo mv doctl /usr/local/bin/

          # Install do-app-sandbox
          pip install do-app-sandbox

      - name: Authenticate doctl
        run: doctl auth init -t ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Validate app spec exists
        run: |
          if [ ! -f "${{ inputs.app_spec_path }}" ]; then
            echo "::error::App spec not found at ${{ inputs.app_spec_path }}"
            exit 1
          fi

      - name: Get app info from spec
        id: appinfo
        run: |
          SPEC_PATH="${{ inputs.app_spec_path }}"

          # Get app name
          APP_NAME=$(yq '.name' "$SPEC_PATH" 2>/dev/null || echo "")
          if [ -z "$APP_NAME" ] || [ "$APP_NAME" = "null" ]; then
            echo "::error::Could not read app name from $SPEC_PATH"
            exit 1
          fi
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT

          # Get component name (first service)
          COMPONENT_NAME=$(yq '.services[0].name' "$SPEC_PATH" 2>/dev/null || echo "")
          if [ -z "$COMPONENT_NAME" ] || [ "$COMPONENT_NAME" = "null" ]; then
            echo "::error::Could not read component name from $SPEC_PATH"
            exit 1
          fi
          echo "component_name=$COMPONENT_NAME" >> $GITHUB_OUTPUT

          echo "App: $APP_NAME, Component: $COMPONENT_NAME"

      - name: Get app ID from DigitalOcean
        id: appid
        run: |
          APP_NAME="${{ steps.appinfo.outputs.app_name }}"

          # Get app ID by name
          APP_ID=$(doctl apps list -o json | jq -r ".[] | select(.spec.name == \"$APP_NAME\") | .id" | head -1)

          if [ -z "$APP_ID" ] || [ "$APP_ID" = "null" ]; then
            echo "::error::App '$APP_NAME' not found. Run 'deploy' action first."
            echo "## Error: App Not Found" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "App **$APP_NAME** was not found on DigitalOcean." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Run the workflow with **action: deploy** first to create the app." >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          echo "app_id=$APP_ID" >> $GITHUB_OUTPUT
          echo "Found app ID: $APP_ID"

      - name: Check app health
        run: |
          APP_ID="${{ steps.appid.outputs.app_id }}"

          # Get deployment status
          PHASE=$(doctl apps get "$APP_ID" -o json | jq -r '.[0].active_deployment.phase // "UNKNOWN"')

          if [ "$PHASE" != "ACTIVE" ]; then
            echo "::error::App is not healthy (phase: $PHASE). Check logs or redeploy."
            echo "## Error: App Not Healthy" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "App deployment phase: **$PHASE**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The app must be in ACTIVE state to update env vars." >> $GITHUB_STEP_SUMMARY
            echo "Check the app logs or run a fresh deploy." >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          echo "App is healthy (phase: $PHASE)"

      - name: Extract and write env vars
        run: |
          SPEC_PATH="${{ inputs.app_spec_path }}"
          APP_ID="${{ steps.appid.outputs.app_id }}"
          COMPONENT_NAME="${{ steps.appinfo.outputs.component_name }}"
          INCLUDE_ONLY="${{ inputs.include_only_env_vars }}"
          APP_NAME="${{ steps.appinfo.outputs.app_name }}"

          # System vars to exclude (infrastructure/platform vars)
          EXCLUDE_VARS="GITHUB_REPO_URL|GITHUB_TOKEN|GITHUB_BRANCH|GITHUB_SYNC_INTERVAL|WORKSPACE_PATH|DEV_START_COMMAND|APP_DIR|PRE_DEPLOY_COMMAND|PRE_DEPLOY_TIMEOUT|POST_DEPLOY_COMMAND|POST_DEPLOY_TIMEOUT|BASE_URL|APP_URL|APP_DOMAIN|APP_ID|COMMIT_HASH|PUBLIC_URL|ENABLE_DEV_HEALTH|DEV_HEALTH_PORT|WELCOME_PAGE_PORT|GITHUB_REPO_FOLDER"

          echo "Extracting environment variables from $SPEC_PATH..."
          if [ -n "$INCLUDE_ONLY" ]; then
            echo "Filtering to only include: $INCLUDE_ONLY"
          else
            echo "Updating all app-specific environment variables"
          fi
          echo ""

          # Read existing .env from container (for comparison)
          echo "Reading existing environment variables from container..."
          EXISTING_ENV=$(sandbox exec "$APP_ID" "$COMPONENT_NAME" "cat /workspaces/app/.env 2>/dev/null" || echo "")
          if [ -n "$EXISTING_ENV" ]; then
            echo "Found existing .env file in container"
          else
            echo "No existing .env file found (will create new)"
          fi
          echo ""

          # Initialize tracking
          ENV_CONTENT=""
          VAR_COUNT=0
          UPDATED_KEYS=""
          UPDATED_PREV=""
          UPDATED_NEW=""
          UPDATED_SECRET=""
          SKIPPED_SYSTEM=""
          SKIPPED_EMPTY=""
          SKIPPED_BINDABLE=""
          SKIPPED_FILTER=""
          SKIPPED_UNRESOLVED=""

          # Helper function to get previous value
          get_prev_value() {
            local key="$1"
            echo "$EXISTING_ENV" | grep "^$key=" | cut -d'=' -f2- || echo ""
          }

          # Read each env var from the spec
          while IFS= read -r line; do
            KEY=$(echo "$line" | cut -d'=' -f1)
            VALUE=$(echo "$line" | cut -d'=' -f2-)

            # Skip system vars
            if echo "$KEY" | grep -qE "^($EXCLUDE_VARS)$"; then
              echo "  Skipping system var: $KEY"
              SKIPPED_SYSTEM="${SKIPPED_SYSTEM}${KEY}|"
              continue
            fi

            # If include_only is set, check if this var is in the list
            if [ -n "$INCLUDE_ONLY" ]; then
              if ! echo ",$INCLUDE_ONLY," | grep -q ",$KEY,"; then
                echo "  Skipping (not in include list): $KEY"
                SKIPPED_FILTER="${SKIPPED_FILTER}${KEY}|"
                continue
              fi
            fi

            # Skip empty values
            if [ -z "$VALUE" ] || [ "$VALUE" = "null" ] || [ "$VALUE" = '""' ]; then
              echo "  Skipping empty var: $KEY"
              SKIPPED_EMPTY="${SKIPPED_EMPTY}${KEY}|"
              continue
            fi

            # Skip bindable vars (contain ${APP_ or ${_self.)
            if echo "$VALUE" | grep -qE '\$\{(APP_|_self\.)'; then
              echo "  Skipping bindable var: $KEY"
              SKIPPED_BINDABLE="${SKIPPED_BINDABLE}${KEY}|"
              continue
            fi

            # Check if this var is marked as SECRET in the app spec
            IS_SECRET=$(yq -r ".services[0].envs[] | select(.key == \"$KEY\") | .type // \"\"" "$SPEC_PATH")

            # Substitute ${VAR} placeholders with environment values
            RESOLVED_VALUE="$VALUE"
            while echo "$RESOLVED_VALUE" | grep -q '\${[^}]*}'; do
              PLACEHOLDER=$(echo "$RESOLVED_VALUE" | grep -o '\${[^}]*}' | head -1)
              VAR_NAME=$(echo "$PLACEHOLDER" | sed 's/\${//;s/}//')
              VAR_VALUE="${!VAR_NAME:-}"

              if [ -n "$VAR_VALUE" ]; then
                RESOLVED_VALUE="${RESOLVED_VALUE//$PLACEHOLDER/$VAR_VALUE}"
              else
                echo "  Warning: No value for $VAR_NAME in $KEY"
                break
              fi
            done

            # Skip if still has unresolved placeholders
            if echo "$RESOLVED_VALUE" | grep -q '\${'; then
              echo "  Skipping unresolved var: $KEY"
              SKIPPED_UNRESOLVED="${SKIPPED_UNRESOLVED}${KEY}|"
              continue
            fi

            # Get previous value for comparison
            PREV_VALUE=$(get_prev_value "$KEY")
            if [ -z "$PREV_VALUE" ]; then
              PREV_VALUE="(not set)"
            fi

            # Track the update
            ENV_CONTENT="${ENV_CONTENT}${KEY}=${RESOLVED_VALUE}"$'\n'
            VAR_COUNT=$((VAR_COUNT + 1))

            # Store tracking info (using | as delimiter)
            UPDATED_KEYS="${UPDATED_KEYS}${KEY}|"
            if [ "$IS_SECRET" = "SECRET" ]; then
              UPDATED_PREV="${UPDATED_PREV}***|"
              UPDATED_NEW="${UPDATED_NEW}*** (secret)|"
              UPDATED_SECRET="${UPDATED_SECRET}true|"
              echo "  Added: $KEY (secret)"
            else
              # Escape pipe characters in values for safe storage
              SAFE_PREV=$(echo "$PREV_VALUE" | tr '|' '_')
              SAFE_NEW=$(echo "$RESOLVED_VALUE" | tr '|' '_')
              UPDATED_PREV="${UPDATED_PREV}${SAFE_PREV}|"
              UPDATED_NEW="${UPDATED_NEW}${SAFE_NEW}|"
              UPDATED_SECRET="${UPDATED_SECRET}false|"
              echo "  Added: $KEY"
            fi
          done < <(yq -r '.services[0].envs[] | .key + "=" + (.value // "")' "$SPEC_PATH" 2>/dev/null)

          # Generate summary header
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Environment Variables Update" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**App:** $APP_NAME" >> $GITHUB_STEP_SUMMARY
          echo "**Component:** $COMPONENT_NAME" >> $GITHUB_STEP_SUMMARY
          if [ -n "$INCLUDE_ONLY" ]; then
            echo "**Filter:** \`$INCLUDE_ONLY\`" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ $VAR_COUNT -eq 0 ]; then
            echo "::warning::No app-specific environment variables found to update."
            echo "### No Variables Updated" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            if [ -n "$INCLUDE_ONLY" ]; then
              echo "No variables matched the include filter: \`$INCLUDE_ONLY\`" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "Check that the variable names are correct and exist in your app spec." >> $GITHUB_STEP_SUMMARY
            else
              echo "All variables in the app spec are either system vars or empty." >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo ""
            echo "Found $VAR_COUNT app-specific environment variable(s) to update."

            # Write .env file to container
            echo ""
            echo "Writing .env file to container..."
            echo "$ENV_CONTENT" > /tmp/env_content.txt
            cat /tmp/env_content.txt | sandbox exec "$APP_ID" "$COMPONENT_NAME" "cat > /workspaces/app/.env"

            # Create trigger file
            sandbox exec "$APP_ID" "$COMPONENT_NAME" "touch /workspaces/app/.env_updated"

            echo "Environment variables written to container"
            echo "Trigger file created (.env_updated)"

            # Generate Updated variables table
            echo "### Updated ($VAR_COUNT variables)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Variable | Previous | New |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|----------|-----|" >> $GITHUB_STEP_SUMMARY

            # Parse tracking arrays and output table rows
            IFS='|' read -ra KEYS_ARR <<< "$UPDATED_KEYS"
            IFS='|' read -ra PREV_ARR <<< "$UPDATED_PREV"
            IFS='|' read -ra NEW_ARR <<< "$UPDATED_NEW"

            for i in "${!KEYS_ARR[@]}"; do
              if [ -n "${KEYS_ARR[$i]}" ]; then
                # Truncate long values for display
                PREV_DISPLAY="${PREV_ARR[$i]}"
                NEW_DISPLAY="${NEW_ARR[$i]}"
                if [ ${#PREV_DISPLAY} -gt 40 ]; then
                  PREV_DISPLAY="${PREV_DISPLAY:0:37}..."
                fi
                if [ ${#NEW_DISPLAY} -gt 40 ]; then
                  NEW_DISPLAY="${NEW_DISPLAY:0:37}..."
                fi
                echo "| \`${KEYS_ARR[$i]}\` | \`$PREV_DISPLAY\` | \`$NEW_DISPLAY\` |" >> $GITHUB_STEP_SUMMARY
              fi
            done
          fi

          # Generate Skipped variables section (if any)
          TOTAL_SKIPPED=0
          for list in "$SKIPPED_SYSTEM" "$SKIPPED_EMPTY" "$SKIPPED_BINDABLE" "$SKIPPED_FILTER" "$SKIPPED_UNRESOLVED"; do
            if [ -n "$list" ]; then
              count=$(echo "$list" | tr -cd '|' | wc -c)
              TOTAL_SKIPPED=$((TOTAL_SKIPPED + count))
            fi
          done

          if [ $TOTAL_SKIPPED -gt 0 ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "<details>" >> $GITHUB_STEP_SUMMARY
            echo "<summary>Skipped ($TOTAL_SKIPPED variables)</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Variable | Reason |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|--------|" >> $GITHUB_STEP_SUMMARY

            # Output skipped system vars
            IFS='|' read -ra SYS_ARR <<< "$SKIPPED_SYSTEM"
            for var in "${SYS_ARR[@]}"; do
              [ -n "$var" ] && echo "| \`$var\` | System variable |" >> $GITHUB_STEP_SUMMARY
            done

            # Output skipped empty vars
            IFS='|' read -ra EMPTY_ARR <<< "$SKIPPED_EMPTY"
            for var in "${EMPTY_ARR[@]}"; do
              [ -n "$var" ] && echo "| \`$var\` | Empty value |" >> $GITHUB_STEP_SUMMARY
            done

            # Output skipped bindable vars
            IFS='|' read -ra BIND_ARR <<< "$SKIPPED_BINDABLE"
            for var in "${BIND_ARR[@]}"; do
              [ -n "$var" ] && echo "| \`$var\` | Bindable variable |" >> $GITHUB_STEP_SUMMARY
            done

            # Output skipped filter vars
            IFS='|' read -ra FILT_ARR <<< "$SKIPPED_FILTER"
            for var in "${FILT_ARR[@]}"; do
              [ -n "$var" ] && echo "| \`$var\` | Not in include filter |" >> $GITHUB_STEP_SUMMARY
            done

            # Output skipped unresolved vars
            IFS='|' read -ra UNRES_ARR <<< "$SKIPPED_UNRESOLVED"
            for var in "${UNRES_ARR[@]}"; do
              [ -n "$var" ] && echo "| \`$var\` | Unresolved placeholder |" >> $GITHUB_STEP_SUMMARY
            done

            echo "" >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
          fi

          # Footer
          if [ $VAR_COUNT -gt 0 ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "---" >> $GITHUB_STEP_SUMMARY
            echo "The dev server will restart automatically to load the new environment variables (~10 seconds)." >> $GITHUB_STEP_SUMMARY
          fi
